import 'package:pallet_pro_app/src/features/inventory/data/models/pallet.dart';
import 'package:pallet_pro_app/src/features/inventory/data/repositories/pallet_repository.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
// TODO: Import custom exceptions
// import 'package:pallet_pro_app/src/core/exceptions/app_exceptions.dart';

class SupabasePalletRepository implements PalletRepository {
  final SupabaseClient _supabaseClient;
  final String _tableName = 'pallets'; // Assuming table name is 'pallets'

  SupabasePalletRepository(this._supabaseClient);

  String _getCurrentUserId() {
    final user = _supabaseClient.auth.currentUser;
    if (user == null) {
      // TODO: Replace with AuthException
      throw Exception('User not authenticated');
    }
    return user.id;
  }

  @override
  Future<Pallet> createPallet(Pallet pallet) async {
    final userId = _getCurrentUserId();
    try {
      // Use toJson() which respects @JsonKey for DB names
      final palletData = pallet.toJson();
      // Ensure user_id is set for RLS
      palletData['user_id'] = userId;
      // Remove 'id' as it's typically generated by DB or handled separately
      palletData.remove('id');
       // Ensure timestamps are set if not provided (DB might handle this too)
      palletData['created_at'] ??= DateTime.now().toIso8601String();
      palletData['updated_at'] ??= DateTime.now().toIso8601String();


      final response = await _supabaseClient
          .from(_tableName)
          .insert(palletData)
          .select()
          .single();

      return Pallet.fromJson(response);
    } on PostgrestException catch (e) {
      // TODO: Map to DatabaseException.creationFailed
      print('Error creating pallet: ${e.message}');
      throw Exception('Database error creating pallet: ${e.message}');
    } catch (e) {
      // TODO: Map to generic exception
      print('Unexpected error creating pallet: $e');
      throw Exception('Unexpected error creating pallet: $e');
    }
  }

  @override
  Future<Pallet?> getPalletById(String id) async {
    final userId = _getCurrentUserId();
    try {
      final response = await _supabaseClient
          .from(_tableName)
          .select()
          .eq('id', id)
          .eq('user_id', userId) // Ensure user owns the pallet
          .maybeSingle();

      return response == null ? null : Pallet.fromJson(response);
    } on PostgrestException catch (e) {
      // TODO: Map to DatabaseException.fetchFailed
      print('Error fetching pallet $id: ${e.message}');
      throw Exception('Database error fetching pallet: ${e.message}');
    } catch (e) {
      // TODO: Map to generic exception
      print('Unexpected error fetching pallet $id: $e');
      throw Exception('Unexpected error fetching pallet: $e');
    }
  }

  @override
  Future<List<Pallet>> getAllPallets() async {
    final userId = _getCurrentUserId();
    try {
      final response = await _supabaseClient
          .from(_tableName)
          .select()
          .eq('user_id', userId)
          .order('created_at', ascending: false); // Example ordering

      // Map list of json maps to list of Pallet objects
      return response.map((json) => Pallet.fromJson(json)).toList();

    } on PostgrestException catch (e) {
      // TODO: Map to DatabaseException.fetchFailed
      print('Error fetching all pallets: ${e.message}');
      throw Exception('Database error fetching pallets: ${e.message}');
    } catch (e) {
      // TODO: Map to generic exception
      print('Unexpected error fetching all pallets: $e');
      throw Exception('Unexpected error fetching pallets: $e');
    }
  }

  @override
  Future<Pallet> updatePallet(Pallet pallet) async {
    final userId = _getCurrentUserId();
    try {
      final palletData = pallet.toJson();
      // Ensure user_id and id are not in the update payload itself
      palletData.remove('user_id');
      palletData.remove('id');
      // Ensure updated_at is set
      palletData['updated_at'] = DateTime.now().toIso8601String();

      final response = await _supabaseClient
          .from(_tableName)
          .update(palletData)
          .eq('id', pallet.id)
          .eq('user_id', userId) // Ensure user owns the pallet
          .select()
          .single();

      return Pallet.fromJson(response);
    } on PostgrestException catch (e) {
       // TODO: Map to DatabaseException.updateFailed
      print('Error updating pallet ${pallet.id}: ${e.message}');
      throw Exception('Database error updating pallet: ${e.message}');
    } catch (e) {
      // TODO: Map to generic exception
      print('Unexpected error updating pallet ${pallet.id}: $e');
      throw Exception('Unexpected error updating pallet: $e');
    }
  }

  @override
  Future<void> deletePallet(String id) async {
    final userId = _getCurrentUserId();
    try {
      await _supabaseClient
          .from(_tableName)
          .delete()
          .eq('id', id)
          .eq('user_id', userId); // Ensure user owns the pallet

      // Note: Deleting a pallet might require deleting associated items/expenses first,
      // depending on database constraints (e.g., FOREIGN KEY with ON DELETE RESTRICT).
      // This might need to be handled here or at a higher service level.
    } on PostgrestException catch (e) {
      // TODO: Map to DatabaseException.deleteFailed
      print('Error deleting pallet $id: ${e.message}');
      throw Exception('Database error deleting pallet: ${e.message}');
    } catch (e) {
       // TODO: Map to generic exception
      print('Unexpected error deleting pallet $id: $e');
      throw Exception('Unexpected error deleting pallet: $e');
    }
  }
} 